/*
* Copyright (C) 2012 Chris Neasbitt
* Author: Chris Neasbitt
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package edu.uga.cs.fluxbuster.analytics;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReferenceArray;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.joda.time.DateTime;

import edu.uga.cs.fluxbuster.db.DBInterface;
import edu.uga.cs.fluxbuster.db.DBInterfaceFactory;
import edu.uga.cs.fluxbuster.utils.PropertiesUtils;

/**
 * This class calculates the ip and domain based similarities between 
 * the clusters generated by two runs of hierarchical clustering
 * 
 * @author Chris Neasbitt
 */
public class ClusterSimilarityCalculator {

	private Properties properties = null;
	
	private static String SIMILARITY_NUMTHREADSKEY = "SIMILARITY_NUMTHREADS";
	
	private static Log log = LogFactory.getLog(ClusterSimilarityCalculator.class);
	
	/**
	 * The Enum SIM_TYPE represents a type of similarity.
	 */
	public static enum SIM_TYPE {/** The IP. */ IP, 
		/** The DOMAINNAME. */ DOMAINNAME};
	
	/**
	 * Instantiates a new cluster similarity calculator.
	 *
	 * @throws IOException if the ClusterSimilarityCalculator.properties file
	 * 		can not be loaded
	 */
	public ClusterSimilarityCalculator() throws IOException{
		properties = PropertiesUtils.loadAppWideProperties();
	}
	
	/**
	 * Update all cluster similarities in the database between the run on the
	 * supplied date and the run one day previous.
	 *
	 * @param adate the date of the first clustering run
	 */
	public void updateClusterSimilarities(Date adate){
		DateTime adt = new DateTime(adate.getTime());
		adt.minusDays(1);
		Date bdate = new Date(adt.getMillis());
		this.updateClusterSimilarities(adate, bdate);
	}
	
	
	/**
	 * Update all cluster similarities in the database between the runs on the
	 * two supplied dates.
	 *
	 * @param adate the date of the first clustering run
	 * @param bdate the date of the second clustering run
	 */
	public void updateClusterSimilarities(Date adate, Date bdate){
		try {
			updateIpClusterSimilarities(adate, bdate);
			updateDomainnameClusterSimilarities(adate, bdate);
		} catch (Exception e) {
			if(log.isErrorEnabled()){
				log.error("Error calculating cluster similarities.", e);
			}
		}
		
	}
	
	/**
	 * Update ip-based cluster similarities in the database between the runs on 
	 * the two supplied dates.
	 *
	 * @param adate the date of the first clustering run
	 * @param bdate the date of the second clustering run
	 * @throws Exception if unable to calculate or store the similarity results
	 */
	public void updateIpClusterSimilarities(Date adate, Date bdate) throws Exception{
		storeIpClusterSimiliarities(calculateIpSimilarities(adate, bdate));
	}
	
	/**
	 * Update domainname-based cluster similarities in the database between the runs 
	 * on the two supplied dates.
	 *
	 * @param adate the date of the first clustering run
	 * @param bdate the date of the second clustering run
	 * @throws Exception if unable to calculate or store the similarity results
	 */
	public void updateDomainnameClusterSimilarities(Date adate, Date bdate) throws Exception{
		storeDomainnameClusterSimiliarities(calculateDomainnameSimilarities(adate, bdate));
	}
	
	/**
	 * Store ip-based cluster similiarities in the database.
	 *
	 * @param sims the cluster similarities
	 */
	public void storeIpClusterSimiliarities(List<ClusterSimilarity> sims){
		DBInterface db = DBInterfaceFactory.loadDBInterface();
		db.storeIpClusterSimilarities(sims);
	}
	
	/**
	 * Store domainname-based cluster similiarities in the database.
	 *
	 * @param sims the cluster similarities
	 */
	public void storeDomainnameClusterSimiliarities(List<ClusterSimilarity> sims){
		DBInterface db = DBInterfaceFactory.loadDBInterface();
		db.storeDomainnameClusterSimilarities(sims);		
	}
	
	/**
	 * Calculate ip-based cluster similarities between all of the clusters generated
	 * during the runs on the two supplied dates.
	 * 
	 * @param adate the date of the first clustering run
	 * @param bdate the date of the second clustering run
	 * @return the list of ip-based cluster similarities
	 * @throws IOException if the similarities could not be calculated
	 */
	public List<ClusterSimilarity> calculateIpSimilarities(Date adate, Date bdate) throws IOException{
		return calculateSimularities(adate, bdate, SIM_TYPE.IP);
	}
	
	/**
	 * Calculate domainname-based cluster similarities between all of the clusters generated
	 * during the runs on the two supplied dates.
	 *
	 * @param adate the date of the first clustering run
	 * @param bdate the date of the second clustering run
	 * @return the list of domainname-based cluster similarities
	 * @throws IOException if the similarities could not be calculated
	 */
	public List<ClusterSimilarity> calculateDomainnameSimilarities(Date adate, Date bdate) throws IOException{
		return calculateSimularities(adate, bdate, SIM_TYPE.DOMAINNAME);
	}
	
	/**
	 * Calculate the desired type of cluster similarity between all of the 
	 * clusters generated during the runs on the two supplied dates.
	 *
	 * @param adate the date of the first clustering run
	 * @param bdate the date of the second clustering run
	 * @param type the type of similarity to calculate
	 * @return the list of cluster similarities of the supplied type
	 * @throws IOException if can not spawn similarity calculator threads
	 */
	private List<ClusterSimilarity> calculateSimularities(Date adate, Date bdate, 
			SIM_TYPE type) throws IOException{
		List<ClusterSimilarity> result = new ArrayList<ClusterSimilarity>();
		int numthreads = Integer.parseInt(properties.getProperty(SIMILARITY_NUMTHREADSKEY));
		SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");
		
		List<Integer> aclusters = this.getClusterIDs(adate);
		List<Integer> bclusters = this.getClusterIDs(bdate);
		if(log.isDebugEnabled()){
			log.debug("aclusters size:" + aclusters.size());
			log.debug("bclusters size:" + bclusters.size());
		}
		
		AtomicReferenceArray<AtomicReferenceArray<Double>> sims = 
				new AtomicReferenceArray<AtomicReferenceArray<Double>>(aclusters.size() + 1);
		for(int i = 1; i < aclusters.size() + 1; i++){
			sims.getAndSet(i, new AtomicReferenceArray<Double>(bclusters.size() + 1));
		}
		
		ExecutorService service = Executors.newFixedThreadPool(numthreads);
		int asize = aclusters.size() / numthreads;
		int bsize = bclusters.size() / numthreads;
		for(int i = 1; i <= aclusters.size(); i += asize){
			int iend = 0;
			if(i + asize < aclusters.size()){
				iend = i + asize;
			} else {
				iend = i + (aclusters.size() - i);
			}
			List<Integer> asublist = aclusters.subList(i, iend);
			for(int j = 1; j <= bclusters.size(); j += bsize){
				int jend = 0;
				if(j + bsize < bclusters.size()){
					jend = j + bsize;
				} else {
					jend = j + (bclusters.size() - j);
				}
				List<Integer> bsublist = bclusters.subList(j, jend);
				
				switch(type){
				case IP:
					service.execute(new IpSimilarityCalculatorThread(DBInterfaceFactory.loadDBInterface(), 
							df.format(adate),  df.format(bdate), asublist, bsublist, sims));
					break;
				case DOMAINNAME:
					service.execute(new DomainnameSimilarityCalculatorThread(DBInterfaceFactory.loadDBInterface(), 
							df.format(adate),  df.format(bdate), asublist, bsublist, sims));
					break;
				}
			}
		}

		service.shutdown();
		try {
			while (!service.awaitTermination(30, TimeUnit.SECONDS));
		} catch (InterruptedException e) {
			if(log.isWarnEnabled()){
				log.warn("", e);
			}
		}
				
		
		for(int i = 1; i < sims.length(); i++){
			AtomicReferenceArray<Double> row = sims.get(i);
			for(int j = 1; j < row.length(); j++){
				Double value = row.get(j);
				if(log.isDebugEnabled()){
					log.debug("Sim values: " + adate + " " + bdate + 
							" " + i + " " + j + " " + value);
				}
				if(value != null) {
					ClusterSimilarity temp = new ClusterSimilarity(adate, bdate, i, j, row.get(j));
					if(log.isDebugEnabled()){
						log.debug("Adding: " + temp);
					}
					result.add(temp);
				}
			}
		}
		return result;		
	}

	
	/**
	 * Gets the cluster id's for the clusters generated during the supplied
	 * run date.
	 *
	 * @param adate the date of the clustering run
	 * @return the list of cluster id's
	 */
	private List<Integer> getClusterIDs(Date adate){
		DBInterface db = DBInterfaceFactory.loadDBInterface();
		return db.getClusterIds(adate);
	}
}
