/*
 * Copyright (C) 2009 Roberto Perdisci
 * Author: Roberto Perdisci
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package edu.uga.cs.fluxbuster.clustering.hierarchicalclustering;

import java.io.IOException;
import java.util.Vector;

/**
 * An implementation of agglomerative hierarchical clustering.
 * 
 * @author Roberto Perdisci
 */
public class HierarchicalClustering {

	static final long serialVersionUID = -1235809600124455376L;

	private static final String LINE_SEP = System.getProperty("line.separator");

	private Dendrogram dendrogram;

	/**
	 * The linkage type to use during clustering.
	 */
	public enum LinkageType { /** single (minimum) linkage. */ SINGLE_LINKAGE, 
		/** complete (maximum) linkage. */ COMPLETE_LINKAGE };

	private double m_cutHeight = 0;
	
	private LinkageType m_LinkMethod = LinkageType.SINGLE_LINKAGE;

	/**
	 * Instantiates hierarchical clustering with single linkage
	 * and a cut height of Double.MAX_VALUE.
	 */
	public HierarchicalClustering() throws Exception {
		this(LinkageType.SINGLE_LINKAGE, Double.MAX_VALUE);
	}

	/**
	 * Instantiates hierarchical clustering with a cut height 
	 * of Double.MAX_VALUE.
	 *
	 * @param linkage the linkage type
	 */
	public HierarchicalClustering(LinkageType linkage){
		this(linkage, Double.MAX_VALUE);
	}

	/**
	 * Instantiates hierarchical clustering with single linkage.
	 *
	 * @param cutHeight the cut height
	 */
	public HierarchicalClustering(double cutHeight){
		this(LinkageType.SINGLE_LINKAGE, cutHeight);
	}

	/**
	 * Instantiates hierarchical clustering.
	 *
	 * @param linkage the linkage type
	 * @param cutHeight the cut height
	 */
	public HierarchicalClustering(LinkageType linkage, double cutHeight){
		this.setLinkMethod(linkage);
		this.setCutHeight(cutHeight);
	}

	/**
	 * Sets the cut height.
	 *
	 * @param h the cut height
	 */
	public void setCutHeight(double h){
		if (h < 0) {
			throw new RuntimeException("Cut height must be > 0");
		}
		m_cutHeight = h;
	}

	/**
	 * Gets the cut height.
	 *
	 * @return the cut height
	 */
	public double getCutHeight() {
		return m_cutHeight;
	}

	/**
	 * Sets the linkage type.
	 *
	 * @param method the linkage type
	 */
	public void setLinkMethod(LinkageType method) {
		m_LinkMethod = method;
	}

	/**
	 * Gets the linkage type.
	 *
	 * @return the linkage type
	 */
	public LinkageType getLinkMethod() {
		return m_LinkMethod;
	}

	/**
	 * Gets the dendrogram generated by clustering.
	 *
	 * @return the dendrogram
	 */
	public Dendrogram getDendrogram() {
		return dendrogram;
	}

	/**
	 * Runs the hierarchical clustering algorithm on the supplied
	 * distance matrix.
	 *
	 * @param distMatrix the distance matrix
	 * @param maxCutHeight the maximum cut height
	 */
	public void runClusterer(DistanceMatrix distMatrix, double maxCutHeight) {
		dendrogram = new Dendrogram();
		double currentHeight = 0;

		Vector<HCluster> clusters = computeInitialClusters(distMatrix
				.getNumInstances());

		while (clusters.size() > 1) {
			ClusterIndexPair pair = distMatrix.findClosestClusterPair();
			// if the distance between the closest pair is greater than
			// the max cut height we stop
			if (pair.getDist() > maxCutHeight) {
				break;
			}
			if (pair.getDist() > currentHeight) { // updates the dendrogram
													// before continuing
				dendrogram.addClusters(currentHeight, clusters);
				currentHeight = pair.getDist();
			}

			HCluster c = HCluster.merge(clusters.get(pair.getI()),
					clusters.get(pair.getJ()));
			clusters = updateClusters(clusters, c, pair);
			distMatrix.update(pair);
		}
		// completes the top part of the dendrogram
		dendrogram.addClusters(currentHeight, clusters);

		System.gc();
	}

	// merges clusters until there is a single cluster left or the maxCutHeight
	// is reached
	/**
	 * Runs the hierarchical clustering algorithm on the distance
	 * matrix at the supplied path.
	 *
	 * @param distMatrixPath the path to the distance matrix file
	 * @param maxCutHeight the max cut height
	 * @throws IOException if the distance matrix file can not be read
	 */
	public void runClusterer(String distMatrixPath, double maxCutHeight)
			throws IOException {
		DistanceMatrix distMatrix = new DistanceMatrix(distMatrixPath,
				m_LinkMethod);
		this.runClusterer(distMatrix, maxCutHeight);
	}

	// merges clusters until there is a single cluster left or until the preset
	// cut height
	// is reached
	/**
	 * Runs the hierarchical clustering algorithm on the distance
	 * matrix at the supplied path.
	 *
	 * @param distMatrixPath the path to the distance matrix file
	 * @throws IOException if the distance matrix file can not be read
	 */
	public void runClusterer(String distMatrixPath) throws IOException {
		runClusterer(distMatrixPath, this.getCutHeight());
	}

	/**
	 * Initializes the clustering algorithm. At the beginning each 
	 * cluster contains only one instance (only the index of the 
	 * instance in the dataset).
	 *
	 * @param numInstances the num instances in the dataset
	 * @return the initialized clusters
	 */
	private Vector<HCluster> computeInitialClusters(int numInstances) {
		Vector<HCluster> v = new Vector<HCluster>();

		for (int i = 0; i < numInstances; i++) {
			HCluster c = new HCluster(i);
			v.add(c);
		}

		return v;
	}

	/**
	 * Update this list of clusters after two clusters have been merged.
	 *
	 * @param clusters the list of clusters
	 * @param c the new merged cluster
	 * @param pair the indexes of the clusters merged
	 * @return the updated list of clusters
	 */
	private Vector<HCluster> updateClusters(Vector<HCluster> clusters,
			HCluster c, ClusterIndexPair pair) {

		clusters.set(pair.getI(), c);
		clusters.remove(pair.getJ());

		return clusters;
	}

	/**
	 * Gets the clusters at a cut height.
	 *
	 * @param cut the cut height
	 * @return the clusters at the cut height
	 */
	public Vector<HCluster> getClusters(double cut) {
		return dendrogram.getClusters(cut);
	}

	/**
	 * Get the number of clusters at the preset cut height.
	 *
	 * @return the number of clusters
	 */
	public int numberOfClusters(){
		double cutH = 0;
		for (double h : dendrogram.getHeights().keySet()) {
			if (h <= m_cutHeight)
				cutH = h;
			else
				break;
		}
		dendrogram.print(cutH); // only for printing purposes
		return dendrogram.getHeights().get(cutH).size();
	}

	/**
	 * Returns a string representing this HierarchicalClustering object.
	 * 
	 * @return a string representing this HierarchicalClustering object.
	 */
	@Override
	public String toString() {
		return "Number of clusters = " + this.getClusters(m_cutHeight).size()
				+ LINE_SEP + LINE_SEP;
	}
}
